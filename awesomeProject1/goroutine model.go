package main

func main() {
	/*
							线程可以视为进程中的控制流，一个进程至少会包含一个线程，因为一个进程中至少得有一个控制流持续运行
							随着进程的创建而被创建的线程称为主线程
							线程是独立的，一个线程被阻断并不影响其他线程；但是线程不能独立进程存在
							线程模型：用户级线程模型，内核级线程模型，两级线程模型
						1.内核级线程模型（c++,java)：
							对操作系统的线程进行简单的封装，由操作系统调度
							应用层面的线程和操作系统上的线程是一对一的
							创建、销毁、处理都由操作系统处理，性能受影响
						2.用户级线程模型
							多对一，多个用户级线程和一个内核的线程相对应
							许多语言的协程就是这样实现的
							但是缺点：一旦内核线程（kes)被调度出cpu，连接它的应用级线程就会全部变为阻塞状态（被挂起）
							所以这些语言会把自己一些阻塞的操作封装起来变为完全的非阻塞形式，在要阻塞的地方上主动让出自己
							并且通过某种方式通知或唤醒其他执行的用户线程在内核线程上运行，这样进程就不会阻塞了
						3.两级线程模型（混合线程模型）
							多对多，兼有上面两种的优点，当一个阻塞后立即连接另一个内核线程
							但是实现起来很麻烦，需要用户级实现
					//了解goroutine的机制，理解scheduler的实现
					实现scheduler的实现需要四个结构：M、G、P、Sched（像java的JVM）
					前三个定义在runtime.h里，Sched定义在proc.c中
						Shed结构是调度器，它维护有存储M和G的队列以及调度器的一些状态信息
						M结构是Machine，系统线程，由操作系统管理，goroutine就是在M上跑的
				M是一个很大的结构，里面维护着小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等信息
						P是Processor，逻辑处理器，用来执行goroutine,维护 一个goroutine队列，也就是runqeue
				Processor是我们从N：1调度到M:N的重要部分
						G是goroutine的核心结构，又叫上下文环境，包含了栈，指令指针，以及其他对调度goroutine的重要信息，例如阻塞的channel
				一个正常运行的并发模型：
						单核处理器下，所有goroutine运行在同一个M系统线程上，M系统线程维护一个processor，任何时刻，一个processor只有一个goroutine来执行
			其他goroutine在等待，运行完自己的时间片后，让出G，回到自己的runqeue中；多核处理器下，为了运行goroutine，会有多个M系统线程，每个M系统线程持有一个processor
				当发生阻塞时：例如我们的P下的一个goroutine发生阻塞，系统就会调用创建一个新的系统线程，把阻塞的线程和阻塞的goroutine保持连接
		P还有其他排队的goroutine和新的系统线程构成链接，转到新的线程运行。也就是说运行的线程可能是一对多，但是阻塞的线程一定是一对一
				当其中一个M下的P中的runqeue(排队的goroutine)执行完成后,不能让它闲着，会偷取另外一个M上的P的goroutine
		这样会产生一个问题，一个goroutine在不同的M上需要申请一些资源，比如内存。但是资源的全局的，所以反复的进行调动会带来不必要的损耗，P的妙用就在于此
		我们让P去管理这些goroutine，P先申请一些资源给底下的goroutine，每次需要切换M的时候，新的M就从P中获取已经申请好的资源，如果没有的话
		再申请全局内存，在全局申请的时候会多拿一部分，以便后面的高效使用；而且P解耦了G和M 的关系（本来G和M是链接在一起的）假如M上运行了一个阻塞的G，其余等待的G可以和P一起迁移到
		不阻塞的M下，使我们的goroutine总能运行起来
	*/
}
